import contextlib
from collections import defaultdict

import sqlalchemy
import sqlalchemy.dialects.mssql

from ..query_language import Column, QueryNode, Table, Value, ValueFromRow
from .base import BaseQueryEngine


def make_table_expression(table_name, columns):
    """
    Return a SQLAlchemy object representing a table with the given name and
    columns
    """
    return sqlalchemy.Table(
        table_name,
        sqlalchemy.MetaData(),
        *[sqlalchemy.Column(column) for column in columns],
    )


def get_joined_tables(query):
    """
    Given a query object return a list of all tables referenced
    """
    tables = []
    from_exprs = list(query.froms)
    while from_exprs:
        next_expr = from_exprs.pop()
        if isinstance(next_expr, sqlalchemy.sql.selectable.Join):
            from_exprs.extend([next_expr.left, next_expr.right])
        else:
            tables.append(next_expr)
    # The above algorithm produces tables in right to left order, but it makes
    # more sense to return them as left to right
    tables.reverse()
    return tables


class MssqlQueryEngine(BaseQueryEngine):

    sqlalchemy_dialect = sqlalchemy.dialects.mssql

    def __init__(self, column_definitions, backend):
        super().__init__(column_definitions, backend)
        self._engine = None
        # Walk the nodes and identify output groups
        self.output_groups = self.get_output_groups(column_definitions)
        self.output_group_tables = {}
        self.output_group_tables_queries = {}

    #
    # QUERY DAG METHODS AND NODE INTERACTION
    #
    def get_output_groups(self, nodes):
        """
        Walk over all nodes in the query DAG looking for output nodes (leaf nodes which
        represent a value or a column of values) and group them together by "type" and
        "source" (source being the parent node from which they are derived). Each such
        group of outputs can be generated by a single query so we want them grouped together.
        """
        output_groups = defaultdict(list)
        for node in self.walk_query_dag(nodes.values()):
            if self.is_output_node(node):
                output_groups[self.get_type_and_source(node)].append(node)
        return output_groups

    def walk_query_dag(self, nodes):
        parents = []
        for node in nodes:
            yield node
            for attr in ("source", "value"):
                reference = getattr(node, attr, None)
                if isinstance(reference, QueryNode):
                    parents.append(reference)
        if parents:
            yield from self.walk_query_dag(parents)

    @staticmethod
    def is_output_node(node):
        return isinstance(node, (Value, Column))

    def get_type_and_source(self, node):
        assert self.is_output_node(node)
        return type(node), node.source

    @staticmethod
    def get_output_column_name(node):
        # TODO deal with ValueFromAggregate
        if isinstance(node, (ValueFromRow, Column)):
            return node.column
        else:
            raise TypeError(f"Unhandled type: {node}")

    @staticmethod
    def get_node_list(node):
        """For a single node, get a list of it and all its parents in order"""
        node_list = []
        while True:
            node_list.append(node)
            if type(node) is Table:
                break
            else:
                node = node.source
        node_list.reverse()
        return node_list

    #
    # DATABASE CONNECTION
    #
    @property
    def engine(self):
        if self._engine is None:
            engine_url = sqlalchemy.engine.make_url(self.backend.database_url)
            engine_url = engine_url.set(drivername="mssql+pymssql")
            self._engine = sqlalchemy.create_engine(engine_url, echo=True, future=True)
        return self._engine

    #
    # MSSQL-SPECIFIC QUERIES
    #
    def create_output_group_tables(self):
        """Queries to generate and populate interim tables for each output"""
        # For each group of output nodes (nodes that produce a single output value),
        # make a table object representing a temporary table into which we will write the required
        # values
        for i, (group, output_nodes) in enumerate(self.output_groups.items()):
            table_name = f"group_table_{i}"
            columns = {self.get_output_column_name(output) for output in output_nodes}
            self.output_group_tables[group] = make_table_expression(
                table_name, {"patient_id"} | columns
            )

        # For each group of output nodes, build a query expression
        # to populate the associated temporary table
        self.output_group_tables_queries = {
            group: self.get_query_expression(output_nodes)
            for group, output_nodes in self.output_groups.items()
        }

    def get_select_expression(self, base_table, columns):
        # every table must have a patient_id column; select it and the specified columns
        columns = sorted({"patient_id"}.union(columns))
        table_expr = self.backend.get_table_expression(base_table.name)
        column_objs = [table_expr.c[column] for column in columns]
        query = sqlalchemy.select(column_objs).select_from(table_expr)
        return query

    def get_query_expression(self, output_nodes):
        """
        From a group of output nodes that represent the route to a single output value,
        generate the query that will return the value from its source table(s)
        """
        # output_nodes must all be of the same group so we arbitrarily use the
        # first one
        output_type, query_node = self.get_type_and_source(output_nodes[0])

        # Queries (currently) always have a linear structure so we can
        # decompose them into a list
        node_list = self.get_node_list(query_node)
        # The start of the list should always be an unfiltered Table
        base_table = node_list.pop(0)
        assert isinstance(base_table, Table)

        # TODO For now, we only deal with selecting columns, will need to add filters and aggregates
        selected_columns = {node.column for node in output_nodes}
        query = self.get_select_expression(base_table, selected_columns)

        return query

    def get_population_table_query(self, population_table_name=None):
        # TODO currently just select all patients; needs a minimal aggregation implementation (exists)
        population_table_name = population_table_name or "practice_registrations"
        population_table = make_table_expression(population_table_name, {"PatientId"})
        return sqlalchemy.select(
            [population_table.c.PatientId.label("patient_id")]
        ).select_from(population_table)

    def get_value_expression(self, value):
        """
        Given a single value output node, select it from its interim table
        Return the expression to select it, and the table to select it from
        """
        # Every value is an output node at the moment
        table = self.output_group_tables[self.get_type_and_source(value)]
        column = self.get_output_column_name(value)
        value_expr = table.c[column]
        return value_expr, table

    @staticmethod
    def include_joined_table(query, table):
        if table.name in [t.name for t in get_joined_tables(query)]:
            return query
        join = sqlalchemy.join(
            query.froms[0],
            table,
            query.selected_columns.patient_id == table.c.patient_id,
            isouter=True,
        )
        return query.select_from(join)

    def generate_results_query(self):
        """Query to generate the final single results table"""
        column_definitions = self.column_definitions.copy()
        # `population` is a special-cased boolean column, it doesn't appear
        # itself in the output but it determines what rows are included
        # TODO Currently just uses a default population table and expression
        # Build the base results table from the population table
        results_query = self.get_population_table_query()

        # Build big JOIN query which selects the results
        for column_name, output_node in column_definitions.items():
            # For each output column, generate the query that selects it from its interim table
            column, table = self.get_value_expression(output_node)
            # Then generate the query to join on it
            results_query = self.include_joined_table(results_query, table)
            # Add this column to the final selected results
            results_query = results_query.add_columns(column.label(column_name))
        return results_query

    def get_sql(self):
        """Build the SQL"""
        self.create_output_group_tables()
        sql = []
        # Generate each of the interim output group tables and populate them
        for group, table in self.output_group_tables.items():
            query = self.output_group_tables_queries[group]
            query_sql = self.query_expression_to_sql(query)
            sql.append(f"SELECT * INTO {table.name} FROM (\n{query_sql}\n) t")
        # Add the big query that creates the base population table and its columns,
        # selected from the output group tables
        sql.append(self.query_expression_to_sql(self.generate_results_query()))
        return "\n\n\n".join(sql)

    def query_expression_to_sql(self, query):
        return str(
            query.compile(
                dialect=self.sqlalchemy_dialect.dialect(),
                compile_kwargs={"literal_binds": True},
            )
        )

    @contextlib.contextmanager
    def execute_query(self):
        """Execute a query against an MSSQL backend"""
        sql = self.get_sql()
        with self.engine.connect() as cursor:
            result = cursor.execute(sqlalchemy.text(sql))
            yield result
